/add string specific escapes (\", \\)
/add constants
/add arithmetic expressions evaluated at compile time
/add register relative offsets e.g. "ld r1, [fp + 3]" (literals and identifiers will be expressions, evaluated at compile time e.g. "ld r1, [label + 23 * 23])
rename "parameters" to "arguments" or maybe "operands"
maybe have each operation allowed to generate multiple opcodes and have "push {r1, r2, r3}" and "pop {r1, r2, r3}" or "push r1, r2, r3", "pop r1, r2, r3" (could maybe be done in hardware)
negative numbers in argument converts it to the equivalent instruction, e.g. "add r1, -3" gets generated as "sub r1, 3"
/scopes for identifiers (labels, and constants) i.e. {} blocks

/imports
make string into expression

make memory clocked

use verilator

use i32 types
use Wrapped<> to allow integer overflows

check immediates are correct bit length, and error instead of truncating
maybe have two different values in symbol table for u32 and i32

maybe have parameters all be expressions

expressions = arithemtic expression, string, register, register offset, indirect

maybe combine register and register-offset, i.e. register + 0 = register

make imports paths relative to the importees path instead of relative to where the assembler program is ran
in lib.rs there is a bunch of clones for the cache, maybe possible to reduce it

interns on identifiers
