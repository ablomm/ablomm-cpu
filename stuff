-maybe have each operation allowed to generate multiple opcodes and have "push {r1, r2, r3}" and "pop {r1, r2, r3}" or "push r1, r2, r3", "pop r1, r2, r3" (could maybe be done in hardware)

make memory clocked

use verilator

-have times 1, and times 0 on register or register offset work and
-have divide by 1 for register and register offset work

progress bar

push has 4 bit for number of operands,
if number is 0, then treat rest as immediate

have operations as an expression, operations are just literals

have multi word instruction, 

have an implicit symbol called pc, which is the current address (this should be knowable at assembly time), then we could do stuff like
add pc, label - pc; to jump using offsets

pass 1: generate file queue
pass 2: type inferance (post order), including inserting types to export_file_map
pass 3: calculate addresses (files, labels)
	also fill symbol table labels with correct addresses to allow more information for calculating num_words
	re-insert all symbols because labels are now included
pass 4: fill sybol table assignments (labels should already be done in previous pass) (post order)
pass 5: generate operations

make get_recursive() return ref, maybe use a enum with either Borrow or Ref for & or Ref<T>
